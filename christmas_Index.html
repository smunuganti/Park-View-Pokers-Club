<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Park View Pokers Club</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & Babel for in-browser JSX transpilation -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @keyframes snow {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(100vh) rotate(360deg); }
        }
        .animate-snow {
            animation: snow linear infinite;
        }
        ::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .custom-scrollbar::-webkit-scrollbar { display: block; width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #10b981; border-radius: 10px; opacity: 0.3; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Lucide Icon Component Wrapper ---
        const Icon = ({ name, size = 20, className = "", strokeWidth = 2, fill = "none" }) => {
            const iconRef = useRef(null);
            useEffect(() => {
                if (iconRef.current) {
                    lucide.createIcons({
                        targets: [iconRef.current]
                    });
                }
            }, [name]);

            return <i ref={iconRef} data-lucide={name} style={{ width: size, height: size }} className={className} stroke-width={strokeWidth} fill={fill}></i>;
        };

        const STORAGE_VER = "v129_hosting_ready"; 
        const STORAGE_KEY = `pvp_club_ledger_${STORAGE_VER}`;
        const THEME_KEY = `pvp_theme_${STORAGE_VER}`;
        const DEFAULT_ROSTER = ['Player 1', 'Player 2', 'Player 3'];

        const App = () => {
            const [showWelcome, setShowWelcome] = useState(true);
            const [isDarkMode, setIsDarkMode] = useState(() => {
                const saved = localStorage.getItem(THEME_KEY);
                return saved === null ? true : saved === 'dark';
            });

            const [game, setGame] = useState(() => {
                const data = localStorage.getItem(STORAGE_KEY);
                if (data) {
                    const parsed = JSON.parse(data);
                    if (parsed && Array.isArray(parsed.players)) return parsed;
                }
                return { players: DEFAULT_ROSTER, rounds: [], history: [], inactive: [] };
            });

            const [isAddingRound, setIsAddingRound] = useState(false);
            const [editingRoundIdx, setEditingRoundIdx] = useState(null); 
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [isHistoryOpen, setIsHistoryOpen] = useState(false);
            const [bustedOverlay, setBustedOverlay] = useState(null); 
            const [newScores, setNewScores] = useState({});
            const [newPlayerName, setNewPlayerName] = useState('');
            const [editIdx, setEditIdx] = useState(null);
            const [editValue, setEditValue] = useState('');
            const [error, setError] = useState(null);
            const [shareFeedback, setShareFeedback] = useState(false);
            
            const scrollRef = useRef(null);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(game));
                localStorage.setItem(THEME_KEY, isDarkMode ? 'dark' : 'light');
                if (!isAddingRound && !editingRoundIdx && scrollRef.current && game.rounds.length > 0) {
                    scrollRef.current.scrollTo({ top: scrollRef.current.scrollHeight, behavior: 'smooth' });
                }
            }, [game, isDarkMode, isAddingRound, editingRoundIdx]);

            const players = game.players;
            const rounds = game.rounds;
            const history = game.history;
            const inactive = game.inactive || [];

            const totals = useMemo(() => {
                return players.map((_, pIdx) => 
                    rounds.reduce((sum, r) => sum + (Array.isArray(r) ? (r[pIdx] || 0) : 0), 0)
                );
            }, [players, rounds]);

            const minTotal = useMemo(() => {
                const activeTotals = totals.filter((_, i) => !inactive.includes(i));
                return activeTotals.length > 0 ? Math.min(...activeTotals) : Infinity;
            }, [totals, inactive]);

            const leaderIdx = useMemo(() => {
                if (rounds.length === 0) return -1;
                return totals.findIndex((t, i) => !inactive.includes(i) && t === minTotal);
            }, [totals, inactive, minTotal, rounds]);

            const handleScoreEntry = (isEdit = false) => {
                setError(null);
                const entry = players.map((p, i) => {
                    if (inactive.includes(i)) return 0;
                    const v = newScores[p];
                    return (v === "" || v === undefined) ? null : parseInt(v);
                });

                if (entry.some((s, i) => !inactive.includes(i) && (s === null || isNaN(s)))) {
                    setError("Enter score for every active player.");
                    return;
                }
                
                const activeScores = entry.filter((_, i) => !inactive.includes(i));
                if (activeScores.filter(s => s === 0).length !== 1) {
                    setError("Exactly one player must score 0.");
                    return;
                }

                if (isEdit) {
                    const updatedRounds = [...rounds];
                    updatedRounds[editingRoundIdx] = entry;
                    setGame(prev => ({ ...prev, rounds: updatedRounds }));
                    setEditingRoundIdx(null);
                    setNewScores({});
                    return;
                }

                const projected = totals.map((t, i) => t + (entry[i] || 0));
                const bustedIdxs = projected.map((t, i) => (!inactive.includes(i) && t > 201) ? i : -1).filter(i => i !== -1);

                if (bustedIdxs.length > 0) {
                    const safePlayers = projected.filter((t, i) => !bustedIdxs.includes(i) && !inactive.includes(i));
                    const target = (safePlayers.length > 0 ? Math.max(...safePlayers) : 0) + 1;
                    setBustedOverlay({ indices: bustedIdxs, currentIdx: bustedIdxs[0], target, pending: entry, projected });
                } else {
                    saveHand(entry);
                }
            };

            const saveHand = (scores) => {
                setGame(prev => ({ ...prev, rounds: [...prev.rounds, scores] }));
                setNewScores({});
                setIsAddingRound(false);
                setBustedOverlay(null);
            };

            const handleBustChoice = (rejoin) => {
                const scores = [...bustedOverlay.pending];
                const pIdx = bustedOverlay.currentIdx;
                const others = bustedOverlay.projected.filter((_, idx) => idx !== pIdx && !inactive.includes(idx));
                const isDoorClosed = others.some(t => t >= 180);
                let updatedInactive = [...inactive];
                if (rejoin && !isDoorClosed) {
                    scores[pIdx] = bustedOverlay.target - totals[pIdx];
                } else {
                    if (!updatedInactive.includes(pIdx)) updatedInactive.push(pIdx);
                }
                const nextIdxs = bustedOverlay.indices.filter(i => i !== pIdx);
                if (nextIdxs.length === 0) {
                    setGame(prev => ({ ...prev, inactive: updatedInactive }));
                    saveHand(scores);
                } else {
                    setBustedOverlay({ ...bustedOverlay, currentIdx: nextIdxs[0], indices: nextIdxs, pending: scores });
                    setGame(prev => ({ ...prev, inactive: updatedInactive }));
                }
            };

            const addPlayer = (midGame = false) => {
                const name = newPlayerName.trim();
                if (!name || players.length >= 7) return;
                if (midGame && rounds.length > 0) {
                    const maxScore = Math.max(...totals);
                    const joinScore = maxScore + 1;
                    setGame(prev => ({
                        ...prev, players: [...prev.players, name],
                        rounds: prev.rounds.map((r, i) => i === 0 ? [...r, joinScore] : [...r, 0])
                    }));
                } else {
                    setGame(p => ({ ...p, players: [...p.players, name], rounds: [], inactive: [] }));
                }
                setNewPlayerName('');
            };

            // Simplified Components
            const Snowfall = () => {
                const flakes = useMemo(() => Array.from({ length: 40 }).map((_, i) => ({
                    id: i, left: Math.random() * 100, delay: Math.random() * 5,
                    duration: 5 + Math.random() * 10, size: 2 + Math.random() * 4
                })), []);
                return (
                    <div className="fixed inset-0 pointer-events-none overflow-hidden z-50">
                        {flakes.map(f => (
                            <div key={f.id} className="absolute top-[-10px] bg-white rounded-full animate-snow"
                                style={{ left: `${f.left}%`, width: `${f.size}px`, height: `${f.size}px`, opacity: 0.4, animationDuration: `${f.duration}s`, animationDelay: `${f.delay}s` }}
                            />
                        ))}
                    </div>
                );
            };

            if (showWelcome) {
                return (
                    <div className={`fixed inset-0 flex flex-col items-center justify-center p-8 transition-colors duration-500 overflow-hidden ${isDarkMode ? 'bg-emerald-950 text-white' : 'bg-slate-50 text-slate-900'}`}>
                        <Snowfall />
                        <div className="max-w-sm w-full text-center relative z-10">
                            <div className="bg-rose-600 text-white px-4 py-1 rounded-full text-[10px] font-black uppercase tracking-widest mb-4 inline-block shadow-lg">Christmas Edition</div>
                            <h1 className="text-4xl font-black uppercase italic text-emerald-500 mb-1">Park View Pokers</h1>
                            <h2 className="text-6xl font-black uppercase tracking-widest mb-12 text-rose-600">Club</h2>
                            <button onClick={() => setShowWelcome(false)} className="w-full h-16 bg-rose-600 hover:bg-rose-500 text-white rounded-2xl font-black uppercase tracking-widest shadow-2xl active:scale-95 transition-all flex items-center justify-center gap-3">
                                Enter the Club <Icon name="chevron-right" />
                            </button>
                            <button onClick={() => setIsDarkMode(!isDarkMode)} className="mt-12 p-4 bg-black/10 rounded-full">
                                <Icon name={isDarkMode ? "sun" : "moon"} />
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className={`fixed inset-0 flex flex-col transition-colors duration-500 ${isDarkMode ? 'bg-emerald-950 text-white' : 'bg-white text-slate-900'}`}>
                    <Snowfall />
                    <nav className={`flex-none border-b px-4 py-4 z-40 ${isDarkMode ? 'bg-emerald-900/40 border-emerald-800/40 backdrop-blur-md' : 'bg-white border-slate-200 shadow-sm'}`}>
                        <div className="max-w-4xl mx-auto flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <div className="w-10 h-10 bg-rose-600 rounded-2xl flex items-center justify-center text-white"><Icon name="gift" /></div>
                                <div className="text-left leading-none">
                                    <h1 className="text-[10px] font-black uppercase text-emerald-500">Park View Pokers</h1>
                                    <span className="text-[8px] font-bold text-rose-500 uppercase">Club Ledger</span>
                                </div>
                            </div>
                            <div className="flex items-center gap-1">
                                <button onClick={() => setIsDarkMode(!isDarkMode)} className="p-2 opacity-50"><Icon name={isDarkMode ? "sun" : "moon"} /></button>
                                <button onClick={() => setIsSettingsOpen(true)} className="p-2 opacity-50"><Icon name="settings-2" /></button>
                            </div>
                        </div>
                    </nav>

                    <div className="flex-1 flex flex-col overflow-hidden relative">
                        <div className={`flex-none flex border-b-2 z-20 ${isDarkMode ? 'bg-emerald-950 border-emerald-900/50' : 'bg-white border-slate-200'}`}>
                            <div className="w-10 text-[8px] font-black text-slate-500 uppercase flex items-center justify-center">Hand</div>
                            <div className="flex-1 flex">
                                {players.map((name, i) => (
                                    <div key={i} className={`flex-1 border-r py-3 text-center truncate ${inactive.includes(i) ? 'opacity-30 grayscale' : ''}`}>
                                        <span className="text-[10px] font-black uppercase truncate block">{name}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div ref={scrollRef} className="flex-1 overflow-y-auto no-scrollbar">
                            {rounds.map((round, rIdx) => (
                                <div key={rIdx} className="flex border-b border-emerald-900/10">
                                    <div className="w-10 flex flex-col items-center justify-center py-4 text-[10px] font-bold text-slate-500">{rIdx + 1}</div>
                                    <div className="flex-1 flex">
                                        {round.map((score, cIdx) => (
                                            <div key={cIdx} className="flex-1 border-r flex items-center justify-center py-4">
                                                {score === 0 ? <span className="w-6 h-6 rounded-full bg-rose-600 text-white flex items-center justify-center text-[10px] font-black">0</span> : <span className="text-sm font-bold tabular-nums">{score}</span>}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div className={`flex-none flex text-white shadow-2xl ${isDarkMode ? 'bg-emerald-800' : 'bg-emerald-600'}`}>
                            <div className="w-10 text-[8px] font-black uppercase flex items-center justify-center bg-black/20 italic">Total</div>
                            <div className="flex-1 flex">
                                {totals.map((total, i) => (
                                    <div key={i} className={`flex-1 py-4 border-r border-white/10 text-center font-black text-lg ${inactive.includes(i) ? 'opacity-50' : ''}`}>
                                        {total} {i === leaderIdx && rounds.length > 0 && "üèÜ"}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="p-5 flex-none">
                        <button onClick={() => setIsAddingRound(true)} className="w-full h-16 bg-rose-600 text-white rounded-3xl font-black uppercase tracking-widest shadow-xl flex items-center justify-center gap-3">
                            <Icon name="plus" size={24} /> Record Hand
                        </button>
                    </div>

                    {/* Simple Round Modal */}
                    {isAddingRound && (
                        <div className="fixed inset-0 z-[60] flex items-end sm:items-center justify-center p-4 bg-black/80 backdrop-blur-md">
                            <div className={`w-full max-w-md rounded-[2.5rem] p-8 ${isDarkMode ? 'bg-emerald-900' : 'bg-white'}`}>
                                <div className="flex justify-between mb-8">
                                    <h3 className="text-xl font-black text-rose-500 uppercase">New Hand</h3>
                                    <button onClick={() => setIsAddingRound(false)} className="text-slate-400"><Icon name="x" size={28} /></button>
                                </div>
                                <div className="grid grid-cols-2 gap-4 mb-8">
                                    {players.map((name, idx) => !inactive.includes(idx) && (
                                        <div key={name} className="flex flex-col">
                                            <label className="text-[10px] font-black uppercase text-emerald-300 mb-1 ml-2">{name}</label>
                                            <input type="number" value={newScores[name] || ''} onChange={e => setNewScores({...newScores, [name]: e.target.value})} className="w-full bg-black/20 p-4 rounded-xl text-center text-2xl font-black outline-none" placeholder="Score" />
                                        </div>
                                    ))}
                                </div>
                                <button onClick={() => handleScoreEntry()} className="w-full bg-rose-600 py-5 rounded-2xl font-black uppercase shadow-xl">Confirm Round</button>
                            </div>
                        </div>
                    )}

                    {/* Simple Settings Modal */}
                    {isSettingsOpen && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md">
                            <div className={`w-full max-w-sm rounded-[2.5rem] p-8 ${isDarkMode ? 'bg-emerald-900' : 'bg-white'}`}>
                                <h3 className="text-xl font-black text-rose-500 uppercase mb-8 flex items-center gap-2"><Icon name="users" /> Registry</h3>
                                <input type="text" value={newPlayerName} onChange={e => setNewPlayerName(e.target.value)} placeholder="Player Name" className="w-full bg-black/20 p-4 rounded-xl mb-4 font-bold outline-none" />
                                <div className="flex gap-2 mb-8">
                                    <button onClick={() => addPlayer(false)} className="flex-1 py-4 bg-slate-800 rounded-xl text-[10px] font-black uppercase">Standard Add</button>
                                    <button onClick={() => addPlayer(true)} className="flex-1 py-4 bg-rose-600 rounded-xl text-[10px] font-black uppercase">Join @ Max+1</button>
                                </div>
                                <button onClick={() => setIsSettingsOpen(false)} className="w-full py-4 bg-emerald-950 rounded-xl font-black uppercase">Done</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>